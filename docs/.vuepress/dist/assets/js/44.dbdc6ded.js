(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{785:function(n,e,t){"use strict";t.r(e);var r=t(34),s=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("现在，我们将要遵循 React 代码的体系结构，一步步的实现我们自己的 React 版本。但是本次并不会将优化以及非必要的特性加入进来。\n如果你有阅读过我以前任何一篇 构建你自己的 React 文章，这次的不同点在于，本次构建是基于 React 的16.8版本，所以这意味着我们可以使用 hooks 来替代 class。\n你可以在之前的文章或者 Didact 代码仓库中了解之前构建的 react。而且这里还有一个内容相同的视频。但是本篇文章包含完整的构建过程，并不会依赖于之前的内容。\n那从头开始，下面是需要我们加入到本次 react 构建中的特性。")]),n._v(" "),t("ul",[t("li",[n._v("步骤一：createElement 函数")]),n._v(" "),t("li",[n._v("步骤二：render 函数")]),n._v(" "),t("li",[n._v("步骤三：Concurrent 模式（了解更多）")]),n._v(" "),t("li",[n._v("步骤四：Fibers（了解更多）")]),n._v(" "),t("li",[n._v("步骤五：渲染和提交")]),n._v(" "),t("li",[n._v("步骤六：Reconciliation（了解更多）")]),n._v(" "),t("li",[n._v("步骤七：函数组件")]),n._v(" "),t("li",[n._v("步骤八：Hooks（了解更多）")])]),n._v(" "),t("p",[n._v("开始之前：回顾\n首先我们回顾一些基本的概念。如果你已经对 React、JSX 和 DOM 元素的原理有一个很好的了解，那么可以跳过这一步。\n我们使用如下 React 应用来作为例子，这个例子只需要三行代码。第一行创建了一个 React 元素。接下来从 DOM 中获取一个节点。最后将 React 元素渲染到获取的 DOM 节点中。")]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" element "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),n._v("h1 title"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"foo"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("Hello"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("/")]),n._v("h1"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" container "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" document"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("getElementById")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"root"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\nReactDOM"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("render")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("element"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" container"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),t("p",[n._v("使用原生 JS 替换掉所有的 React 代码。\n在第一行中使用 JSX 创建了一个元素。但 JSX 并不是有效的 Javascript 代码，所以需要使用原生 JS 来替换掉。\nJSX 可以被 Babel 等编译工具转换为 JS。这个转换过程通常很简单：调用 createElement 函数替换掉标签内的代码，将标签名、props 属性和 childen元素 作为参数传入。")]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// 转换前")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" element "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),n._v("h1 title"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"foo"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("Hello"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("/")]),n._v("h1"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// 转换后")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" element "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" React"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"h1"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v(" title"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"foo"')]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"Hello"')]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),t("p",[n._v("React.createElement  根据参数创建了一个对象。除了一些校验，这就是这个函数做的全部工作。所以我们可以直接使用它的输出来替换掉函数调用。")]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// 转换前")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" element "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" React"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("\n "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"h1"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v(" title"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"foo"')]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"Hello"')]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// 转换后")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" element "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("type")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"h1"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n props"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n   title"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"foo"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n   children"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"Hello"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])])]),t("p",[n._v('这就是一个 React 元素的本质，一个包含两个属性的对象：type 和 props（当然，还有更多属性，但是我们只关注这两个）。\ntype 是一个标识我们想创建的 DOM 元素类型的字符串，当你想创建一个 HTML 元素时，type作为一个 标签名 参数传入到 document.createElemnt 函数中。我们将在第七步中使用它。\nprops 是一个包含所有 JSX 属性的对象，它还有一个特殊的属性：children。\nchildren 在这个例子中是一个字符串，但是它通常都是一个有很多元素的数组。数组中的每个元素还可能有自己的子元素，所以最后所有的元素会组成一个树状结构。\n我们需要替换的另外一部分是 ReactDom.render 函数的调用。\nrender 是 React 改变 DOM 的地方，那么接下来我们自己来实现 DOM 的更新。\n第一步我们根据例子中的元素类型 h1 创建一个 DOM 节点。\n之后我们将所有元素 props 中的属性添加到这个 DOM 节点中。这里需要添加的只有一个 title 属性。\n*（为了避免大家产生疑惑，我使用“元素”代指React元素，使用“节点”代指 DOM 元素。）\n接下来我们为 children 创建节点。这里我们只有一个字符串作为 children，所以只需要创建一个文本节点。\n使用 textNode 而不是设置 innerHTML 是因为之后这样可以以相同的方式去创建其他元素。注意我们是怎么设置 nodeValue 的，就像我们设置 h1 的 title 一样，这就好像字符串有了 props:{nodeValue:"hello"}。\n最后，我们将 文本节点 添加到 h1节点 中，然后将 h1节点 添加到从 DOM 中获取到的 container 节点中。\n现在我们的应用和之前一样，但是没有使用 React 来构建。')]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" element "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("type")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"h1"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  props"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    title"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"foo"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n    children"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"Hello"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n​\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" container "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" document"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("getElementById")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"root"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n​\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" node "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" document"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("element"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("type")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\nnode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"title"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" element"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("props"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("title\n​\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" text "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" document"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createTextNode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('""')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\ntext"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"nodeValue"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" element"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("props"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),n._v("children\n​\nnode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("appendChild")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("text"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\ncontainer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("appendChild")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),t("p",[n._v("第一步 createElement 函数\n让我们以另外一个应用开始，这次我们将会把 React 代码替换为我们自己实现的 React 版本。")]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" element "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),n._v("div id"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"foo"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),n._v("a"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("bar"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("/")]),n._v("a"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),n._v("b "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("/")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("/")]),n._v("div"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" container "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" document"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("getElementById")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"root"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\nReactDOM"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("render")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("element"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" container"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),t("p",[n._v("第一步，我们来实现自己的 createElement。\n让我们将 JSX 转换为 JS，这样我们就可以看到 *createElement 函数是如何被调用。")]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" element "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" React"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("\n "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"div"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("id"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"foo"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n React"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"a"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"bar"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n React"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"b"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("const")]),n._v(" container "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" document"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("getElementById")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"root"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\nReactDOM"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("render")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("element"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" container"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),t("p",[n._v("正如我们在上一步看到的，元素就是一个包含 type 和 props 属性的对象。我们的函数唯一要做的就是去创建一个这样的对象。")]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("function")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("type")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" props"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("...")]),n._v("children"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("return")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("type")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n    props"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n      "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("...")]),n._v("props"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n      children"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])])]),t("p",[n._v('我们使用扩展运算符来处理 props，使用rest参数语法来处理 *children，这样 children 属性将始终是一个数组。\n举个例子，createElement("div") 返回如下：')]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"type"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"div"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"props"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"children"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])])]),t("p",[n._v('createElement("div",null,a) 返回如下：')]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"type"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"div"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"props"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"children"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),n._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])])]),t("p",[n._v('createElement("div",null,a,b) 返回如下：')]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"type"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"div"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"props"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"children"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),n._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])])]),t("p",[n._v("children 数组还可以包含像字符串或者数字这样的基本类型数据。所以我们创建一个特殊的类型：TEXT_ELEMENT 来将所有不是对象的值包装在自己的元素中。\n（React 不会像我们这样包装基本类型值，在没有子元素的情况下创建空数组。我们这样做是为了代码的简洁，对于我们的库，在简洁与性能之间更倾向于前者。）")]),n._v(" "),t("div",{staticClass:"language-ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("function")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("type")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" props"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("...")]),n._v("children"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("return")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("type")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n    props"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n      "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("...")]),n._v("props"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n      children"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v("children"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("map")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("child "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=>")]),n._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("typeof")]),n._v(" child "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("===")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"object"')]),n._v("\n          "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("?")]),n._v(" child\n          "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createTextElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("child"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n      "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("function")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[n._v("createTextElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("text"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("return")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("type")]),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[n._v('"TEXT_ELEMENT"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n    props"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n      nodeValue"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" text"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n      children"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(",")]),n._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])])]),t("p",[n._v("目前我们仍然通过 React 这个名字来调用 createElement。\n为了替换它，让我们给库取一个名字吧。我们需要一个听起来像 React，但是也能暗示其教学目的名字。\n我们可以叫它 Didact（在英文中，didactic是教学的意思）。\nconst Didact = {\ncreateElement,\n}")]),n._v(" "),t("p",[n._v('const element = Didact.createElement(\n"div",\n{ id: "foo" },\nDidact.createElement("a", null, "bar"),\nDidact.createElement("b")\n)\n复制代码\n但是我们还是希望在这里使用 JSX。那我们怎么告诉 babel 去使用 Didact 的 createElement 而不是 React的呢？\n如果我们像这样注释一下，当 babel 转换 JSX 时，就会使用我们定义的函数。\n/** @jsx Didact.createElement */\nconst element = (\n')]),t("div",{attrs:{id:"foo"}},[t("a",[n._v("bar")]),n._v(" "),t("b")]),n._v("\n)\n复制代码\n第二步 render 函数\n接下来，我们来实现 ReactDOM.render  函数。\n现在，我们只需要关注如何把元素放入到 DOM 中。至于如何处理元素的更新和删除，我们会在之后考虑。\nfunction render(element, container) {\n// TODO create dom nodes\n}\nconst Didact = {\ncreateElement,\nrender,\n}\n复制代码\n我们先根据元素的类型创建一个 DOM 节点，之后把这个新节点添加到 container 元素中。\nfunction render(element, container) {\nconst dom = document.createElement(element.type)"),t("p"),n._v(" "),t("p",[n._v("container.appendChild(dom)\n}\n复制代码\n我们通过递归对每个 child 元素执行相同的操作。\nfunction render(element, container) {\nconst dom = document.createElement(element.type)")]),n._v(" "),t("p",[n._v("element.props.children.forEach(child =>\nrender(child, dom)\n)")]),n._v(" "),t("p",[n._v('container.appendChild(dom)\n}\n复制代码\n我们还需要处理一下文本元素，如果元素的类型是 TEXT_ELEMENT，那么就需要创建一个文本节点。\nfunction render(element, container) {\nconst dom =\nelement.type == "TEXT_ELEMENT"\n? document.createTextNode("")\n: document.createElement(element.type)')]),n._v(" "),t("p",[n._v("element.props.children.forEach(child =>\nrender(child, dom)\n)")]),n._v(" "),t("p",[n._v('container.appendChild(dom)\n}\n复制代码\n最后，我们需要做的是，将元素 props 中的属性添加到 DOM 节点上。\nfunction render(element, container) {\nconst dom =\nelement.type == "TEXT_ELEMENT"\n? document.createTextNode("")\n: document.createElement(element.type)')]),n._v(" "),t("p",[n._v('// 将元素 props 中的属性添加到 DOM 节点上\nconst isProperty = key => key !== "children"\nObject.keys(element.props)\n.filter(isProperty)\n.forEach(name => {\ndom[name] = element.props[name]\n})')]),n._v(" "),t("p",[n._v("element.props.children.forEach(child =>\nrender(child, dom)\n)")]),n._v(" "),t("p",[n._v('container.appendChild(dom)\n复制代码\n就这样，我们实现了一个可以渲染 JSX 元素到 DOM 中的库。\nfunction createElement(type, props, ...children) {\nreturn {\ntype,\nprops: {\n...props,\nchildren: children.map(child =>\ntypeof child === "object"\n? child\n: createTextElement(child)\n),\n},\n}\n}\n​\nfunction createTextElement(text) {\nreturn {\ntype: "TEXT_ELEMENT",\nprops: {\nnodeValue: text,\nchildren: [],\n},\n}\n}\n​\nfunction render(element, container) {\nconst dom =\nelement.type == "TEXT_ELEMENT"\n? document.createTextNode("")\n: document.createElement(element.type)\n​\nconst isProperty = key => key !== "children"\nObject.keys(element.props)\n.filter(isProperty)\n.forEach(name => {\ndom[name] = element.props[name]\n})\n​\nelement.props.children.forEach(child =>\nrender(child, dom)\n)\n​\ncontainer.appendChild(dom)\n}\n​\nconst Didact = {\ncreateElement,\nrender,\n}\n​\n/** @jsx Didact.createElement */\nconst element = (\n')]),t("div",{attrs:{id:"foo"}},[t("a",[n._v("bar")]),n._v(" "),t("b")]),n._v('\n)\nconst container = document.getElementById("root")\nDidact.render(element, container)\n复制代码\n大家可以在 codesandbox 看到完整代码。\n第三步 Concurrent 模式\n但是...在我们加入更多特性之前我们需要对代码进行一次重构。\n因为递归调用会存在这样一个问题：\n一旦渲染开始就不会停止。设想一下，如果整个页面包含非常多的元素，渲染过程中就会一直阻塞主进程。如果此时浏览器想去处理一些像用户输入或者保持动画流畅这些高优先级的任务，就需要等到所有的元素渲染完成之后再进行处理，这对于用户来说是非常不好的体验。\n所以我们需要做的是将整个任务拆分为一个个小的子任务，浏览器可以在执行完每一个小任务之后中断渲染流程转而去处理一些其他的事情。\nlet nextUnitOfWork = null\n​\nfunction workLoop(deadline) {\nlet shouldYield = false\nwhile (nextUnitOfWork && !shouldYield) {\nnextUnitOfWork = performUnitOfWork(\nnextUnitOfWork\n)\nshouldYield = deadline.timeRemaining() < 1\n}\nrequestIdleCallback(workLoop)\n}\n​\nrequestIdleCallback(workLoop)\n​\nfunction performUnitOfWork(nextUnitOfWork) {\n// TODO\n}\n复制代码\n我们使用 reqeustIdleCallback 来创建一个循环任务。你可以把 requestIdleCallback 等同于 setTimeout 。只不过 setTimeout 需要我们告诉它什么时候执行，而 requestIdleCallback 会在浏览器主进程空闲时执行回调。\nReact 并没有使用 requestIdleCallback 而是使用的这个调度程序包，但是在概念上两者是一致的。\nrequestIdleCallback 提供了一个 deadline 参数，通过这个参数可以了解到还有多少时间浏览器就会拿回控制权。\n截止到2019年11月，Cocurrent 模式还是不稳定的。循环的稳定版本看起来更像这个:\nwhile (nextUnitOfWork) {'),t("br"),n._v("\nnextUnitOfWork = performUnitOfWork("),t("br"),n._v("\nnextUnitOfWork"),t("br"),n._v("\n)\n}\n复制代码\n开始使用循环，我们需要设置初始子任务，之后需要创建一个 performUnitWork 函数，这个函数不仅要执行当前子任务，还需要返回下一个要执行的子任务。\n第四步 Fibers\n我们使用 fiber 树这种数据结构来连接所有的子任务。\n每一个元素对应一个 fiber，每一个 fiber 就是一个子任务。\n让我给你举个例子。\n如果我们想渲染如下元素：\nDidact.render(\n"),t("div",[t("h1",[t("p"),n._v(" "),t("a")]),n._v(" "),t("h2")]),n._v(",\ncontainer\n)\n复制代码"),t("p"),n._v(" "),t("p",[n._v("在 render 中，我们会创建一个根 fiber，并将它设置为 nextUnitOfWork。剩下的工作则会在 performUnitOfWork 中进行，在这个函数中我们要为每个 fiber 做三件事：")]),n._v(" "),t("p",[n._v("将元素添加到 DOM 中。\n为元素的子元素创建 fiber。\n寻找下一个子任务。")]),n._v(" "),t("p",[n._v('使用这个数据结构的其中一个目的就是为了可以更简单的寻找下一个子任务。这就是为什么每个 fiber 都会指向它的第一个子 fiber、相邻的兄弟 fiber，以及父 fiber。\n当执行完一个 fiber 任务后，如果这个 fiber 有一个子 fiber，那这个子 fiber 就是下一个要执行的子任务。\n举个例子，当处理完 div fiber，接下来就会处理 h1 fiber。\n如果当前 fiber 没有子 fiber，那么就会把它的兄弟 fiber 作为下一个要执行的子任务。\n举个例子，p fiber没有子 fiber，所以我们会在当前 fiber 任务结束后去处理 a fiber。\n如果当前 fiber 既没有子 fiber 也没有兄弟 fiber。就需要去到“叔叔”那里：兄弟 fiber 的父 fiber。就像例子中的 a 和 h2 fiber。\n如果父 fiber 没有兄弟 fiber，就需要继继续向上寻找，直至找到有兄弟 fiber 的 fiber 节点或者到达根 fiber。如果到达根 fiber，就代表已经完成本次渲染的所有工作。\n现在，我们将以上处理逻辑加入到代码中。\n首先，需要从 render 函数中移除创建 DOM 节点的代码。\n我们将创建 DOM 节点的逻辑单独放在 createDom 函数中，这个函数我们会在之后用到。\nfunction createDom(fiber) {\nconst dom =\nfiber.type == "TEXT_ELEMENT"\n? document.createTextNode("")\n: document.createElement(fiber.type)\n​\nconst isProperty = key => key !== "children"\nObject.keys(fiber.props)\n.filter(isProperty)\n.forEach(name => {\ndom[name] = fiber.props[name]\n})\n​\nreturn dom\n}\n复制代码\n在 render 函数中，我们将 fiber 树的根节点赋值给 nextUnitOfWork。\nfunction render(element, container) {\nnextUnitOfWork = {\ndom: container,\nprops: {\nchildren: [element],\n},\n}\n}\n​\nlet nextUnitOfWork = null\n复制代码\n之后，如果浏览器有空闲时间了，就会调用我们的 workLoop,从根节点开始工作。\n首先，我们创建一个节点并将其添加到DOM中。\n我们可以在 fiber.dom 中获取到这个 DOM 节点。\nfunction performUnitOfWork(fiber) {\n// 将元素添加到 DOM 中\nif (!fiber.dom) {\nfiber.dom = createDom(fiber)\n}\n​\nif (fiber.parent) {\nfiber.parent.dom.appendChild(fiber.dom)\n}\n​\n// TODO 为子元素创建 fiber 节点\n// TODO 返回下一个子任务\n}\n复制代码\n之后，我们为每一个子元素创建一个新的 fiber 节点。\n并且根据是否是第一个子节点将其作为孩子节点或者兄弟节点添加到 fiber 树中。\nfunction performUnitOfWork(fiber) {\n// 将元素添加到 DOM 中\nif (!fiber.dom) {\nfiber.dom = createDom(fiber)\n}\n​\nif (fiber.parent) {\nfiber.parent.dom.appendChild(fiber.dom)\n}\n​\n// 为子元素创建 fiber 节点\nconst elements = fiber.props.children\nlet index = 0\nlet prevSibling = null\n​\nwhile (index < elements.length) {\nconst element = elements[index]\n​\nconst newFiber = {\ntype: element.type,\nprops: element.props,\nparent: fiber,\ndom: null,\n}')]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("if (index === 0) {\n  fiber.child = newFiber\n} else {\n  prevSibling.sibling = newFiber\n}\n")])])]),t("p",[n._v("​\nprevSibling = newFiber\nindex++\n}")]),n._v(" "),t("p",[n._v("// TODO 返回下一个子任务\n}\n复制代码\n最后，我们按照子节点、兄弟节点、叔叔节点的顺序依次类推，来找到下一个子任务。\nfunction performUnitOfWork(fiber) {\n// 将元素添加到 DOM 中\nif (!fiber.dom) {\nfiber.dom = createDom(fiber)\n}\n​\nif (fiber.parent) {\nfiber.parent.dom.appendChild(fiber.dom)\n}\n​"),t("br"),n._v("\n// 为子元素创建 fiber 节点\nconst elements = fiber.props.children\nlet index = 0\nlet prevSibling = null\n​\nwhile (index < elements.length) {\nconst element = elements[index]\n​\nconst newFiber = {\ntype: element.type,\nprops: element.props,\nparent: fiber,\ndom: null,\n}")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("if (index === 0) {\n  fiber.child = newFiber\n} else {\n  prevSibling.sibling = newFiber\n}\n")])])]),t("p",[n._v("​\nprevSibling = newFiber\nindex++\n}")]),n._v(" "),t("p",[n._v("// 返回下一个子任务\nif (fiber.child) {\nreturn fiber.child\n}\nlet nextFiber = fiber\nwhile (nextFiber) {\nif (nextFiber.sibling) {\nreturn nextFiber.sibling\n}\nnextFiber = nextFiber.parent\n}\n}\n复制代码\n以上就是 performUnitOfWork 的全部逻辑。\n第五步 渲染与提交阶段\n经过上面一系列的处理，另外一个问题出现了。\n我们在处理一个元素时会为其创建一个节点添加到 DOM 中。但是要记得，浏览器是会打断渲染过程的，这样用户就会看到一个不完整的UI，这不是我们想要看到的结果。\n所以我们需要从 performUnitOfWork 函数中删除添加 DOM 的代码。\nfunction performUnitOfWork(fiber) {\n// 将元素添加到 DOM 中\nif (!fiber.dom) {\nfiber.dom = createDom(fiber)\n}\n​\n//  删除添加 DOM 的部分\n//  if (fiber.parent) {\n//    fiber.parent.dom.appendChild(fiber.dom)\n//  }\n​"),t("br"),n._v("\n// 为子元素创建 fiber 节点\nconst elements = fiber.props.children\nlet index = 0\nlet prevSibling = null\n​\nwhile (index < elements.length) {\nconst element = elements[index]\n​\nconst newFiber = {\ntype: element.type,\nprops: element.props,\nparent: fiber,\ndom: null,\n}")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("if (index === 0) {\n  fiber.child = newFiber\n} else {\n  prevSibling.sibling = newFiber\n}\n")])])]),t("p",[n._v("​\nprevSibling = newFiber\nindex++\n}")]),n._v(" "),t("p",[n._v("// 返回下一个子任务\nif (fiber.child) {\nreturn fiber.child\n}\nlet nextFiber = fiber\nwhile (nextFiber) {\nif (nextFiber.sibling) {\nreturn nextFiber.sibling\n}\nnextFiber = nextFiber.parent\n}\n}\n复制代码\n我们添加一个新的变量指向 fiber 树的根节点。我们可以将其命名为 work in progress root（正在工作流程中的根节点）或者 wipRoot。\nfunction render(element, container) {\nwipRoot = {\ndom: container,\nprops: {\nchildren: [element],\n},\n}\nnextUnitOfWork = wipRoot\n}\n​\nlet nextUnitOfWork = null\nlet wipRoot = null\n复制代码\n这样，直到完成本次渲染的全部工作（此时已经没有下一个子任务）才会将整个 fiber 树提交到 DOM 中。\n我们在 commitRoot 函数中处理添加逻辑。在函数中通过递归的形式将所有节点添加到 DOM 中。\nfunction commitRoot() {\ncommitWork(wipRoot.child)\nwipRoot = null\n}\n​\nfunction commitWork(fiber) {\nif (!fiber) {\nreturn\n}\nconst domParent = fiber.parent.dom\ndomParent.appendChild(fiber.dom)\ncommitWork(fiber.child)\ncommitWork(fiber.sibling)\n}")]),n._v(" "),t("p",[n._v("function workLoop(deadline) {\nlet shouldYield = false\nwhile (nextUnitOfWork && !shouldYield) {\nnextUnitOfWork = performUnitOfWork(\nnextUnitOfWork\n)\nshouldYield = deadline.timeRemaining() < 1\n}")]),n._v(" "),t("p",[n._v("​ // 直到没有下一个子任务，将整个 fiber 树提交到 DOM 节点中\nif (!nextUnitOfWork && wipRoot) {\ncommitRoot()\n}\n​\nrequestIdleCallback(workLoop)\n}\n​\nrequestIdleCallback(workLoop)\n复制代码\n第六步 协调阶段（Reconciliation）\n到目前为止，我们只是将元素添加到了 DOM 中，但是我们怎么去更新或者删除节点呢？\n这正是我们现在要去做的。我们需要将 render 函数中返回的元素与上一次提交到 DOM 中的 fiber 树进行比较。\n所以我们需要在上一个 fiber树提交之后保存对其的引用，我们可以称为 currentRoot。\n我们还需要在每个 fiber 节点中添加一个 alternate 属性。这个属性会保存上一次提交到 DOM 中的fiber节点。\nfunction commitRoot() {\ncommitWork(wipRoot.child)\n// 将 DOM 更新之后，更新当前 fiber 树\ncurrentRoot = wipRoot\nwipRoot = null\n}\n​")]),n._v(" "),t("p",[n._v("function render(element, container) {\nwipRoot = {\ndom: container,\nprops: {\nchildren: [element],\n},\nalternate: currentRoot,\n}\nnextUnitOfWork = wipRoot\n}\n​\nlet nextUnitOfWork = null\n// 增加 currentRoot 用于保存当前提交到 DOM 中的 fiber 树\nlet currentRoot = null\nlet wipRoot = null\n复制代码\n现在，我们将 performUnitOfWork 中关于创建新的 fiber 节点的逻辑移动到一个新的 reconcileChildren 函数中。\nfunction performUnitOfWork(fiber) {\nif (!fiber.dom) {\nfiber.dom = createDom(fiber)\n}\n​\nconst elements = fiber.props.children\n// 将创建新的 fiber 节点的逻辑移动到 reconcileChildren 函数中\nreconcileChildren(fiber, elements)\n​\nif (fiber.child) {\nreturn fiber.child\n}\nlet nextFiber = fiber\nwhile (nextFiber) {\nif (nextFiber.sibling) {\nreturn nextFiber.sibling\n}\nnextFiber = nextFiber.parent\n}\n}")]),n._v(" "),t("p",[n._v("function reconcileChildren(wipFiber, elements) {\nlet index = 0\nlet prevSibling = null\n​\nwhile (index < elements.length) {\nconst element = elements[index]\n​\nconst newFiber = {\ntype: element.type,\nprops: element.props,\nparent: wipFiber,\ndom: null,\n}\n​\nif (index === 0) {\nwipFiber.child = newFiber\n} else {\nprevSibling.sibling = newFiber\n}\n​\nprevSibling = newFiber\nindex++\n}\n}\n复制代码\n在 reconcileChildren 函数中，我们会把旧的 fiber 与新的元素进行协调（比较和复用）。\n我们同时迭代旧的 fiber 的子节点以及我们想要协调的元素数组。\n如果我们忽略掉迭代的代码，那么只剩下最重要的部分：旧的 fiber 和元素，元素是我们想要渲染到 DOM 中的东西，旧的 fiber 是我们上一次要渲染的内容。\n我们需要对它们进行比较，看看是否需要对 DOM 进行任何更改。\nfunction reconcileChildren(wipFiber, elements) {\nlet index = 0\n// 获取旧的 fiber 节点\nlet oldFiber =\nwipFiber.alternate && wipFiber.alternate.child\nlet prevSibling = null\n​")]),n._v(" "),t("p",[n._v("while (\nindex < elements.length ||\noldFiber != null\n){\nconst element = elements[index]\nlet newFiber = null;\n​"),t("br"),n._v("\n// TODO 在这里将旧的 fiber 节点与元素作比较")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("if(oldFiber){\n    oldFiber = oldFiber.sibling;\n}\n")])])]),t("p",[n._v("​\nif (index === 0) {\nwipFiber.child = newFiber\n} else {\nprevSibling.sibling = newFiber\n}\n​\nprevSibling = newFiber\nindex++\n}\n}\n复制代码\n我们使用 type 属性来比较它们：")]),n._v(" "),t("p",[n._v("如果之前的 fiber 节点和新的元素 type 属性相同，那就保留这个 DOM 节点，只需要更新一下新的 props 属性。\n如果 type 属性不同，并且存在新的元素，这就意味着我们需要创建一个新的 DOM 节点。\n如果 type 属性不同，并且存在旧的 fiber 节点，那么就需要移除这个节点。")]),n._v(" "),t("p",[n._v("*（为了在协调阶段可以更好的进行比较，React还在这个阶段使用了 key 属性。举个例子，通过添加 key 属性可以知道数组中的元素是否只是调换了顺序，从而直接复用之前的节点。）\nfunction reconcileChildren(wipFiber, elements) {\nlet index = 0\n// 获取旧的 fiber 节点\nlet oldFiber =\nwipFiber.alternate && wipFiber.alternate.child\nlet prevSibling = null\n​")]),n._v(" "),t("p",[n._v("while (\nindex < elements.length ||\noldFiber != null\n){\nconst element = elements[index]\nlet newFiber = null;\n​"),t("br"),n._v("\n// 在这里将旧的 fiber 节点与元素作比较\nconst sameType =\noldFiber &&\nelement &&\nelement.type == oldFiber.type\n​\nif (sameType) {\n// TODO 更新节点\n}\nif (element && !sameType) {\n// TODO 添加节点\n}\nif (oldFiber && !sameType) {\n// TODO 删除旧的 fiber 中的节点\n}")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("if(oldFiber){\n    oldFiber = oldFiber.sibling;\n}\n")])])]),t("p",[n._v('​\nif (index === 0) {\nwipFiber.child = newFiber\n} else {\nprevSibling.sibling = newFiber\n}\n​\nprevSibling = newFiber\nindex++\n}\n}\n复制代码\n当旧的 fiber 节点与新元素的 type 属性相同时，我们创建新的 fiber 节点时会复用旧的 fiber 节点的 DOM 对象。\n我们还需要给 fiber 节点添加一个 effectTag 的属性。这个属性会在之后的提交阶段用到。\nif (sameType) {\n// 更新节点\nnewFiber = {\ntype: oldFiber.type,\nprops: element.props,\ndom: oldFiber.dom,\nparent: wipFiber,\nalternate: oldFiber,\neffectTag: "UPDATE",\n}\n}\n复制代码\n在当前这个例子中，如果元素需要创建一个新的 DOM 节点，就需要将fiber的 effectTag 属性标记为 PLACEMENT。\nif (element && !sameType) {\n//  添加节点\nnewFiber = {\ntype: element.type,\nprops: element.props,\ndom: null,\nparent: wipFiber,\nalternate: null,\neffectTag: "PLACEMENT",\n}\n}\n复制代码\n如果当前元素需要被删除，那么就不需要创建一个新的 fiber 节点，所以我们将旧的 fiber 节点的 effectTag 属性标记为 DELETION。\nif (oldFiber && !sameType) {\n// 删除旧的 fiber 中的节点\noldFiber.effectTag = "DELETION"\ndeletions.push(oldFiber) // deletions 哪来的？我们来马上分解一下\n}\n复制代码\n但是当我们将 wipRoot 指向的这个 fiber 树提交到 DOM 中时是不包含这个旧的 fiber 节点。\n所以我们需要一个数组用来存储需要被删除的 fiber 节点。\nfunction render(element, container) {\nwipRoot = {\ndom: container,\nprops: {\nchildren: [element],\n},\nalternate: currentRoot,\n}\ndeletions = [] // 新增\nnextUnitOfWork = wipRoot\n}\n​\nlet nextUnitOfWork = null\nlet currentRoot = null\nlet wipRoot = null\n// 新增 deletions 用来存储要删除的 fiber 节点\nlet deletions = null\n复制代码\n这样在我们将改变提交到 DOM 的时候，就可以通过这个数组删除不再需要的 DOM 节点。\nfunction commitRoot() {\ndeletions.forEach(commitWork) //\ncommitWork(wipRoot.child)\ncurrentRoot = wipRoot\nwipRoot = null\n}\n复制代码\n现在，让我们在 commitWork 函数里面根据新加入的 effectTags 属性做一些处理。\n如果 fiber 节点的 effectTag 的属性为 PLACEMENT，我们只需要像之前那样将 DOM 节点放入到父 fiber 对应的 DOM 节点中。\n如果属性为 DELETION，则与前一步相反，我们就需要移除这个 DOM 节点。\n如果属性为 UPDATE，我们就需要根据 props 属性的改变来更新已经存在的 DOM 节点。\nfunction commitWork(fiber) {\nif (!fiber) {\nreturn\n}\nconst domParent = fiber.parent.dom\n// 将新节点添加到 DOM 中\nif (\nfiber.effectTag === "PLACEMENT" &&\nfiber.dom != null\n) {\ndomParent.appendChild(fiber.dom)\n}\n// 更新节点\nelse if (\nfiber.effectTag === "UPDATE" &&\nfiber.dom != null\n) {\n// updateDom 又在哪？呵呵，继续往下看吧\nupdateDom(\nfiber.dom,\nfiber.alternate.props,\nfiber.props\n)\n}\n// 删除节点\nelse if (fiber.effectTag === "DELETION") {\ndomParent.removeChild(fiber.dom)\n}\n​\ncommitWork(fiber.child)\ncommitWork(fiber.sibling)\n}\n复制代码\n我们在 updateDom 函数中来处理更新 DOM 的逻辑。\n我们比较旧的 fiber 节点与新的 fiber 节点之间的 props 属性的差异，删除不存在的属性，设置新的属性，以及更新改变的属性。\nconst isProperty = key => key !== "children"\nconst isNew = (prev, next) => key =>\nprev[key] !== next[key]\nconst isGone = (prev, next) => key => !(key in next)')]),n._v(" "),t("p",[n._v('function updateDom(dom, prevProps, nextProps) {\n// 删除不再需要的属性\nObject.keys(prevProps)\n.filter(isProperty)\n.filter(isGone(prevProps, nextProps))\n.forEach(name => {\ndom[name] = ""\n})\n​\n// 更新或者设置新的属性\nObject.keys(nextProps)\n.filter(isProperty)\n.filter(isNew(prevProps, nextProps))\n.forEach(name => {\ndom[name] = nextProps[name]\n})\n}\n复制代码\n除此之外，我们还要对事件监听这个特殊的 porps 属性进行特殊处理。所以如果 prop 的属性名是以 “on” 为前缀，我们就需要对其进行差异处理。\n如果事件处理函数发生改变，我们就从节点上将这个事件监听移除。\n之后我们再添加新的事件处理函数。\nconst isEvent = key => key.startsWith("on")\nconst isProperty = key =>\nkey !== "children" && !isEvent(key)')]),n._v(" "),t("p",[n._v('const isProperty = key => key !== "children"\nconst isNew = (prev, next) => key =>\nprev[key] !== next[key]\nconst isGone = (prev, next) => key => !(key in next)')]),n._v(" "),t("p",[n._v("function updateDom(dom, prevProps, nextProps) {\n// 删除旧的事件监听\nObject.keys(prevProps)\n.filter(isEvent)\n.filter(\nkey =>\n!(key in nextProps) ||\nisNew(prevProps, nextProps)(key)\n)\n.forEach(name => {\nconst eventType = name\n.toLowerCase()\n.substring(2)\ndom.removeEventListener(\neventType,\nprevProps[name]\n)\n})")]),n._v(" "),t("p",[n._v('// 删除不再需要的属性\nObject.keys(prevProps)\n.filter(isProperty)\n.filter(isGone(prevProps, nextProps))\n.forEach(name => {\ndom[name] = ""\n})\n​\n// 更新或者设置新的属性\nObject.keys(nextProps)\n.filter(isProperty)\n.filter(isNew(prevProps, nextProps))\n.forEach(name => {\ndom[name] = nextProps[name]\n})')]),n._v(" "),t("p",[n._v("// 添加新的事件监听\nObject.keys(nextProps)\n.filter(isEvent)\n.filter(isNew(prevProps, nextProps))\n.forEach(name => {\nconst eventType = name\n.toLowerCase()\n.substring(2)\ndom.addEventListener(\neventType,\nnextProps[name]\n)\n})\n}\n复制代码\n大家可以在codesandbox浏览添加了协调机制的代码版本。\n第七步 函数组件\n接下来我们要做的事情就是增加对函数组件的支持。\n首先，需要更换一下例子。我们使用一个简单的函数组件，这个组件会返回一个 h1 元素。\n/** @jsx Didact.createElement */\nfunction App(props) {\nreturn ")]),t("h1",[n._v("Hi {props.name}")]),n._v("\n}\nconst element = "),t("App",{attrs:{name:"foo"}}),n._v('\nconst container = document.getElementById("root")\nDidact.render(element, container)\n复制代码\n请注意，如果们将 jsx 转换为 那么将会是下面这个样子：\nfunction App(props) {\nreturn Didact.createElement(\n"h1",\nnull,\n"Hi ",\nprops.name\n)\n}\nconst element = Didact.createElement(App, {\nname: "foo",\n})\n复制代码\n函数组件有两个方面的不同：'),t("p"),n._v(" "),t("p",[n._v("代表函数组件的 fiber 节点是没有 DOM 节点的\n子节点是需要运行函数而不是直接 从 props 属性中得到的")]),n._v(" "),t("p",[n._v("如果判断这个 fiber 的 type 属性是一个函数，我们则需要一个不同的更新函数来处理它。\nfunction performUnitOfWork(fiber) {\n// 判断是不是函数组件，如果是，就针对其进行特殊处理\nconst isFunctionComponent =\nfiber.type instanceof Function\nif (isFunctionComponent) {\nupdateFunctionComponent(fiber)\n} else {\nupdateHostComponent(fiber)\n​"),t("br"),n._v("\n// 为子元素创建 fiber 节点\nconst elements = fiber.props.children\nlet index = 0\nlet prevSibling = null\n​\nwhile (index < elements.length) {\nconst element = elements[index]\n​\nconst newFiber = {\ntype: element.type,\nprops: element.props,\nparent: fiber,\ndom: null,\n}")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("if (index === 0) {\n  fiber.child = newFiber\n} else {\n  prevSibling.sibling = newFiber\n}\n")])])]),t("p",[n._v("​\nprevSibling = newFiber\nindex++\n}")]),n._v(" "),t("p",[n._v("// 返回下一个子任务\nif (fiber.child) {\nreturn fiber.child\n}\nlet nextFiber = fiber\nwhile (nextFiber) {\nif (nextFiber.sibling) {\nreturn nextFiber.sibling\n}\nnextFiber = nextFiber.parent\n}\n}")]),n._v(" "),t("p",[n._v('​\nfunction updateFunctionComponent(fiber) {\n// TODO\n}\n​\nfunction updateHostComponent(fiber) {\nif (!fiber.dom) {\nfiber.dom = createDom(fiber)\n}\nreconcileChildren(fiber, fiber.props.children)\n}\n复制代码\n在 updateHostComponent 中我们继续沿用之前逻辑。\n在 updateFunctionComponent 函数中，我们需要调用函数（fiber.type）来获取 children 元素。\n在我们的例子中， fiber.type 属性就是 App 这个函数，我们调用它，会返回一个 h1 元素。\n只要我们拿到了子节点，之后的协调阶段也是和之前一样的，没有什么改变。\nfunction updateFunctionComponent(fiber) {\nconst children = [fiber.type(fiber.props)]\nreconcileChildren(fiber, children)\n}\n复制代码\n我们需要改变的是 commitWork 函数。\nfunction commitWork(fiber) {\nif (!fiber) {\nreturn\n}\n​\nconst domParent = fiber.parent.dom\nif (\nfiber.effectTag === "PLACEMENT" &&\nfiber.dom != null\n) {\ndomParent.appendChild(fiber.dom)\n} else if (\nfiber.effectTag === "UPDATE" &&\nfiber.dom != null\n) {\nupdateDom(\nfiber.dom,\nfiber.alternate.props,\nfiber.props\n)\n} else if (fiber.effectTag === "DELETION") {\ndomParent.removeChild(fiber.dom)\n}\n​\ncommitWork(fiber.child)\ncommitWork(fiber.sibling)\n}\n复制代码\n现在，我们需要针对不包含 DOM 的 fiber 节点做两处改动。\n首先，要找到一个 DOM 节点的父节点，我们需要沿着 fiber 树向上寻找，直到找到一个包含 DOM 节点的fiber。\nfunction commitWork(fiber) {\nif (!fiber) {\nreturn\n}')]),n._v(" "),t("p",[n._v('// 寻找 DOM 节点的父节点\nlet domParentFiber = fiber.parent\nwhile (!domParentFiber.dom) {\ndomParentFiber = domParentFiber.parent\n}\nconst domParent = domParentFiber.dom\n​\nif (\nfiber.effectTag === "PLACEMENT" &&\nfiber.dom != null\n) {\ndomParent.appendChild(fiber.dom)\n} else if (\nfiber.effectTag === "UPDATE" &&\nfiber.dom != null\n) {\nupdateDom(\nfiber.dom,\nfiber.alternate.props,\nfiber.props\n)\n} else if (fiber.effectTag === "DELETION") {\ndomParent.removeChild(fiber.dom)\n}\n​\ncommitWork(fiber.child)\ncommitWork(fiber.sibling)\n}\n复制代码\n当需要移除一个节点时，我们也需要持续寻找直到找到一个包含 DOM 节点的子节点。\nfunction commitWork(fiber) {\nif (!fiber) {\nreturn\n}')]),n._v(" "),t("p",[n._v('let domParentFiber = fiber.parent\nwhile (!domParentFiber.dom) {\ndomParentFiber = domParentFiber.parent\n}\nconst domParent = domParentFiber.dom\n​\nif (\nfiber.effectTag === "PLACEMENT" &&\nfiber.dom != null\n) {\ndomParent.appendChild(fiber.dom)\n} else if (\nfiber.effectTag === "UPDATE" &&\nfiber.dom != null\n) {\nupdateDom(\nfiber.dom,\nfiber.alternate.props,\nfiber.props\n)\n} else if (fiber.effectTag === "DELETION") {\n// 通过 commitDelection 递归直到找到子节点\ncommitDeletion(fiber,domParent);\n}\n​\ncommitWork(fiber.child)\ncommitWork(fiber.sibling)\n}')]),n._v(" "),t("p",[n._v("function commitDeletion(fiber, domParent) {\nif (fiber.dom) {\ndomParent.removeChild(fiber.dom)\n} else {\ncommitDeletion(fiber.child, domParent)\n}\n}\n复制代码\n第八步 Hooks\n最后一步，既然我们使用了函数组件，当然也要给它加上状态。\n让我们将例子替换为一个经典的计算组件，当我们每次点击它，组件中的值加1。\n注意，我们使用 Didact.useState 来获取和更新这个计算值。\nconst Didact = {\ncreateElement,\nrender,\nuseState,\n}\n​\n/** @jsx Didact.createElement */\nfunction Counter() {\n// 使用 Didact.useState 在函数组件内创建状态（useState我们会在稍后实现）\nconst [state, setState] = Didact.useState(1)\nreturn (\n<h1 onClick={() => setState(c => c + 1)}>\nCount: {state}\n"),n._v("\n)\n}\nconst element = "),t("Counter"),n._v('\nconst container = document.getElementById("root")\nDidact.render(element, container)\n复制代码\n在 useState 函数中，会存储以及更新组件的状态。\nfunction updateFunctionComponent(fiber) {\nconst children = [fiber.type(fiber.props)]\nreconcileChildren(fiber, children)\n}\n​\nfunction useState(initial) {\n// TODO\n}\n复制代码\n在调用函数组件之前，我们需要声明一些全局变量以供在 useState 函数中使用。\n首先，我们创建一个 wipFiber 变量（ wip 即是 work in progress，表示参与本次渲染工作的 fiber 节点）。\n我们还需要在 fiber 节点中添加一个 hooks 数组，以支持在同一个组件中多次调用 useState 方法。并且我们还需要对当前 hook 的索引进行记录。\nlet wipFiber = null\nlet hookIndex = null\n​\nfunction updateFunctionComponent(fiber) {\nwipFiber = fiber\nhookIndex = 0\nwipFiber.hooks = []\nconst children = [fiber.type(fiber.props)]\nreconcileChildren(fiber, children)\n}\n​\nfunction useState(initial) {\n// TODO\n}\n复制代码\n当在函数组件中调用 useState 时，我们需要通过 fiber 的 alternate 属性以及 hook 的索引来查看是否存在旧的 hook。\n如果存在旧的 hook，我们则从旧的 hook 中拷贝这个状态到新的 hook，如果不存在我们就使用初始值对 hook 的状态进行初始化。\n之后我们将新的 hook 添加到 fiber 节点上，增加 hook 的索引值（指向下一个hook），之后返回处理好的状态（在例子中即是计算好的数值）。\nfunction useState(initial) {\nconst oldHook =\nwipFiber.alternate &&\nwipFiber.alternate.hooks &&\nwipFiber.alternate.hooks[hookIndex]\nconst hook = {\nstate: oldHook ? oldHook.state : initial,\n}\n​\nwipFiber.hooks.push(hook)\nhookIndex++\nreturn [hook.state]\n}\n复制代码\n并且 useState 还返回了一个用于更新状态的函数，所以我们需要定义一个接收action（在当前例子中，action就是对值进行加1的函数）作为参数的 setState 函数。\n我们需要将 action 添加到 hook 的 queue 数组中。\n之后我们需要做一个与 render 函数中相似的操作，为 wipRoot 赋值一个新的 fiber 作为下一个任务，这样 workLoop 就会开始一个新的渲染阶段。\n但是我们此时还没有处理 action 函数。\n在下一次渲染组件的时候，我们从旧的 hook 中拿到所有的 action，并使用这些action对state进行处理，因此当我们返回状态时，值会被更新。\nfunction useState(initial) {\nconst oldHook =\nwipFiber.alternate &&\nwipFiber.alternate.hooks &&\nwipFiber.alternate.hooks[hookIndex]')],1),n._v(" "),t("p",[n._v("const hook = {\nstate: oldHook ? oldHook.state : initial,\n// 将 action（即更新状态的函数）添加到 queue 数组中\nqueue:[]\n}")]),n._v(" "),t("p",[n._v("// 拿到 action 对 state 进行处理\nconst actions = oldHook ? oldHook.queue : []\nactions.forEach(action => {\nhook.state = action(hook.state)\n})")]),n._v(" "),t("p",[n._v("// setState 将 action 添加到 hook 的 queue 中，创建子任务这样就会重新进行渲染页面\n​ const setState = action => {\nhook.queue.push(action)\nwipRoot = {\ndom: currentRoot.dom,\nprops: currentRoot.props,\nalternate: currentRoot,\n}\nnextUnitOfWork = wipRoot\ndeletions = []\n}")]),n._v(" "),t("p",[n._v("wipFiber.hooks.push(hook)\nhookIndex++")]),n._v(" "),t("p",[n._v("// 将 state 和 setState 暴露出去\nreturn [hook.state,setState]\n}\n复制代码\n就这样，我们构建出了我们自己的 React。\n你可以在 codesandbox 或者 github 中看到完整的源码。\n总结\n除了帮助你理解 React 是如何工作的，本文的其中一个目标是可以让你更容易深入了解 React 的代码库。这就是为什么我们几乎在所有地方都使用与 React 相同的变量以及函数名。\n举个例子，如果你在任何一个真实的 React 应用的函数组件中添加一个断点，那么调用堆栈就会显示给你如下信息：")]),n._v(" "),t("p",[n._v("workLoop\nperformUnitOfWork\nupdateFunctionComponent")]),n._v(" "),t("p",[n._v("我们实现的代码并没有包含很多的 React 特性以及优化。举个例子，以下是 React 与我们的实现做的不同的地方：")]),n._v(" "),t("p",[n._v("在 Didact 中，渲染阶段会遍历整个树。React 则会通过一些机制跳过那些没有发生改变的子树。\n我们还会在提交阶段遍历整个树，React 则只会保留产生影响的 fiber 节点链表。\n每次我们构建一个新的树时，我们会为每个 fiber 创建一个新的对象。但是 React 会复用之前树上的 fiber 节点。\n当 Didact 在渲染阶段收到一个新的更新时，会丢弃之前的工作树，从根节点重新开始。但是 React 会给每一个更新标记一个过期时间戳，通过这个时间戳来决定各更新之间的优先级。\n除此之外还有很多...")]),n._v(" "),t("p",[n._v("这里还有一些你可以比较简单添加的特性：")]),n._v(" "),t("p",[n._v("在 props 中添加样式对象属性（即 style 属性）\n扁平化子元素数组\nuseEffect hook\n将 key 机制引入到协调机制中")]),n._v(" "),t("p",[n._v("如果你在 Didact 中加入了以上任何一个特性或者其他的特性，你可以提一个 PR 到这个 Github 仓库，这样就可以让其他人看到了。\n感谢阅读。\n最后，附上原文地址。")])],1)}),[],!1,null,null,null);e.default=s.exports}}]);